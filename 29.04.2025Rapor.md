# MuhasebeStokWebApp Analiz Raporu (29.04.2025)

Bu rapor, MuhasebeStokWebApp uygulamasının ASP.NET Core MVC + EF Core yapısı kullanılarak geliştirilmiş kod tabanının analizini içermektedir. Analiz, belirtilen temel konulara odaklanmıştır.

## 1. Transaction Yapıları

**Genel Durum:** Uygulamada EF Core'un `IDbContextTransaction` mekanizması kullanılarak transaction yönetimi yapılmaktadır. `UnitOfWork` pattern'i tanımlanmış olsa da, kullanımı tutarlı değildir ve transaction yönetimi ağırlıklı olarak `FaturaController` içerisinde doğrudan `DbContext.Database.BeginTransactionAsync()` ile gerçekleştirilmektedir.

**Fatura Oluşturma (`FaturaController.Create`):**
*   **Kapsam:** Fatura başlık/detay kaydı, `StokHareket` oluşturma, `StokFifoService` çağrıları (giriş/çıkış) ve otomatik `Irsaliye` oluşturma işlemleri **tek bir transaction** içerisinde doğru bir şekilde sarmalanmıştır.
*   **Atomicity:** Bu işlemler için atomicity sağlanmıştır. `try-catch` blokları ile hata durumunda `RollbackAsync` çağrılmaktadır.
*   **Eksiklik:** **Kritik bir eksiklik olarak, ilgili `CariHareket` (muhasebe kaydı) oluşturma işlemi bu transaction bloğu içerisinde yer almamaktadır.** Bu durum, fatura kaydedilse bile cari hesabın güncellenmemesine yol açar.
*   **İç `SaveChanges`:** Transaction bloğu içinde birden fazla `SaveChangesAsync` çağrısı bulunmaktadır. Bu, atomicity'yi bozmasa da, genellikle tek bir `SaveChanges` çağrısı tercih edilir.

**Fatura Güncelleme (`FaturaController.Edit`):**
*   **Kapsam:** Eski durumun geri alınması (StokHareket iptali, FIFO iptali, FaturaDetay silme, CariHareket güncelleme/silme) ve yeni durumun kaydedilmesi (yeni FaturaDetay, StokHareket, FIFO kayıtları, CariHareket) işlemleri **tek bir transaction** içerisinde doğru bir şekilde yönetilmektedir.
*   **Atomicity:** Güncelleme işlemi atomiktir. Rollback mekanizması mevcuttur.
*   **İptal/Geri Alma:** `StokFifoService.FifoKayitlariniIptalEt` metodu, FIFO kayıtlarının iptali ve tüketilen miktarların `KalanMiktar`'a geri eklenmesi için doğru şekilde kullanılmaktadır. Stok hareketleri `Silindi=true` olarak işaretlenmektedir. Cari hareketler de güncellenmekte veya yeniden oluşturulmaktadır.

**Fatura Silme (`FaturaController.DeleteConfirmed` -> `FaturaService.DeleteAsync`):**
*   **Kritik Sorun:** Fatura silme işlemi **transaction yönetimi içermemektedir** ve **eksik uygulanmıştır**.
*   `FaturaService.DeleteAsync` metodu yalnızca Fatura entity'sini `Silindi = true` olarak işaretleyip `SaveChangesAsync` çağırmaktadır.
*   İlişkili `StokHareket`, `StokFifo` kayıtları (ve tüketilen miktarlar) ve `CariHareket` kayıtları **geri alınmamakta veya iptal edilmemektedir.** Bu durum, fatura silindiğinde veri tutarsızlığına (yanlış stok seviyeleri, yanlış maliyetler, yanlış cari bakiye) yol açar. Fatura Güncelleme (`Edit`) metodundaki geri alma mantığı, silme işlemi için de uygulanmalıdır.

**Sonuç:** Transaction yapıları `Create` ve `Edit` işlemleri için kısmen doğru kurgulanmış ancak `Create` işleminde CariHareket eksikliği ve `Delete` işleminde tam bir geri alma mekanizmasının olmaması önemli sorunlardır.

## 2. Servis Mimarisi ve Sorumluluk Ayrımı

**Genel Durum:** Uygulamada servis katmanı (`Services` klasörü) ve repository/unit of work katmanı (`Data/Repositories`) bulunmaktadır. Ancak sorumlulukların dağılımı ve katmanların kullanımı konusunda tutarsızlıklar ve iyileştirme alanları mevcuttur.

*   **Ağır Controller (`FaturaController`):**
    *   Fatura oluşturma ve güncelleme ile ilgili temel iş mantığı (hesaplamalar, entity oluşturma, farklı servislerin orkestrasyonu, transaction yönetimi) büyük ölçüde `FaturaController` içerisinde yer almaktadır. Bu, "Thin Controller, Fat Service/Model" prensibine aykırıdır.
    *   Controller, sık sık doğrudan `ApplicationDbContext`'i kullanarak veri okuma ve hatta yazma işlemleri yapmaktadır (`SaveChangesAsync` çağrıları). Bu durum, Repository ve Unit of Work pattern'lerinin amacını zayıflatmaktadır.
*   **Servislerin Kullanımı:**
    *   `IFaturaService`: `FaturaController` tarafından yalnızca eksik olan `DeleteAsync` işlemi için kullanılmaktadır. Diğer CRUD operasyonları ve iş mantığı controller'da tekrar ele alınmıştır.
    *   `ICariHareketService`: Fatura işlemleri sırasında (`Create` ve `Edit`) kullanılmamaktadır. `Edit` işleminde CariHareket mantığı doğrudan controller'da ele alınmış, `Create` işleminde ise tamamen eksiktir. Servis, yalnızca Kasa ve Banka hareketlerinden CariHareket türetmek için kullanılıyor gibi görünmektedir.
    *   `IStokFifoService`: FIFO mantığı için doğru bir şekilde ayrı bir serviste modülerleştirilmiştir ve `FaturaController` tarafından kullanılmaktadır. Bu, iyi bir örnektir.
    *   `IUnitOfWork`: Tanımlanmış olmasına rağmen, `FaturaController` gibi üst katmanlarda transaction yönetimi ve veri erişimi için sıklıkla bypass edilmektedir. Servisler içinde de kullanımı tutarlı değildir (`CariHareketService` hem `DbContext` hem `IUnitOfWork` inject ederken, `FaturaService` sadece `DbContext` inject etmektedir).
*   **Orkestrasyon:** Fatura oluşturma/güncelleme gibi birden fazla adımı (Fatura, Stok, FIFO, Cari, Irsaliye) içeren işlemlerin koordinasyonu Controller seviyesinde yapılmaktadır. Bu orkestrasyon mantığının, Controller yerine özel bir orkestrasyon servisine veya daha kapsamlı bir `FaturaService`'e taşınması daha uygun olurdu.

**Sonuç:** Servis mimarisi ve sorumluluk ayrımı tam olarak oturmamıştır. Controller'lar gereğinden fazla sorumluluk üstlenmiş, servis katmanı potansiyelinin altında kullanılmış ve veri erişim katmanı (UoW/Repository) tutarlı bir şekilde uygulanmamıştır. FIFO işlemleri için `StokFifoService`'in ayrılması olumlu bir adımdır.

## 3. FIFO Algoritmasının Doğruluğu ve Güvenilirliği (`StokFifoService`)

*   **Algoritma Doğruluğu:**
    *   **Stok Seçimi:** `StokCikisiYap` metodu, çıkış yapılacak ürün için `KalanMiktar > 0` olan, `Aktif`, `!Iptal` ve `!Silindi` durumundaki FIFO kayıtlarını doğru bir şekilde `GirisTarihi` (öncelikli) ve `OlusturmaTarihi` (ikincil) kriterlerine göre sıralayarak en eski stoğun ilk tüketilmesini (FIFO) sağlamaktadır.
    *   **Miktar Tüketimi:** İhtiyaç duyulan miktarı karşılamak için FIFO kayıtları üzerinden doğru bir şekilde iterasyon yapmakta ve her kayıttan `Math.Min(fifo.KalanMiktar, kalanMiktar)` kadar kullanarak `KalanMiktar`'ı doğru bir şekilde güncellemektedir.
    *   **Maliyet Hesaplama:** `StokCikisiYap` metodu, tüketilen her FIFO parçasının maliyetini, o parçanın ait olduğu `StokFifo` kaydının `USDBirimFiyat`'ı üzerinden hesaplamaktadır. Bu, FIFO maliyetlendirme prensibine uygundur (USD bazında). Farklı para birimleri için maliyet hesaplama `GetOrtalamaMaliyet` ve `HesaplaMaliyetAsync` gibi metotlarda ele alınmıştır.
    *   **İptal Mekanizması:** `FifoKayitlariniIptalEt` metodu, bir işleme (örn. fatura) bağlı FIFO girişlerini iptal etmekle kalmaz, aynı zamanda bu işleme bağlı `StokCikisDetay` kayıtlarını bularak tüketilen miktarları ilgili `StokFifo` kayıtlarının `KalanMiktar`'ına geri ekler. Bu, iptal ve düzenleme senaryoları için kritik öneme sahiptir ve doğru uygulanmıştır.
*   **Güvenilirlik ve Eş Zamanlılık:**
    *   **Transaction Yönetimi:** Servis metotları, dışarıdan gelen bir transaction'a katılabilir veya kendi transaction'larını başlatabilir (`ReadCommitted` izolasyon seviyesi ile). Bu, atomicity sağlar.
    *   **Concurrency Riski:** `ReadCommitted` izolasyon seviyesi, aynı ürüne ait FIFO kayıtlarını aynı anda güncellemeye çalışan iki `StokCikisiYap` işlemi arasında teorik bir race condition riski taşır. Bir işlem veriyi okuduktan sonra, diğer işlem aynı veriyi güncelleyip commit edebilir. İlk işlemin kendi güncellemesi, bayat veri üzerinden yapılmış olabilir. Veritabanının satır kilitleme mekanizmaları bu riski azaltsa da, yüksek eş zamanlılık durumlarında yetersiz kalabilir.
    *   **İyileştirme Önerisi:** `StokFifo` entity'sine bir `Timestamp`/`RowVersion` kolonu ekleyerek ve `SaveChangesAsync` sırasında `DbUpdateConcurrencyException`'ı yakalayarak optimistic concurrency kontrolü uygulamak, eş zamanlılık problemlerine karşı daha sağlam bir çözüm sunacaktır.
*   **Döviz Kuru Bağımlılığı:** Stok girişindeki maliyetlerin farklı para birimlerine çevrilmesi (`USDBirimFiyat`, `TLBirimFiyat`, `UZSBirimFiyat`) `IDovizKuruService`'e bağımlıdır. Bu servisin hata vermesi veya güncel kur sağlayamaması durumunda kullanılan fallback mekanizması (varsayılan, potansiyel olarak yanlış kur değerleri) maliyet hesaplamalarının doğruluğunu tehlikeye atabilir.

**Sonuç:** FIFO algoritmasının temel mantığı (stok seçimi, tüketim, maliyetlendirme, iptal) doğru kurgulanmıştır. Ancak eş zamanlılık yönetimi ve döviz kuru servisindeki hatalara karşı kullanılan fallback mekanizmaları potansiyel riskler taşımaktadır.

## 4. Stok ve Cari Hareketlerin Bağlamı

*   **Senkronizasyon:**
    *   `FaturaController.Create` ve `Edit` metotları, Fatura, StokHareket ve StokFifo işlemlerini aynı transaction içinde yaparak bu işlemler arasında senkronizasyonu (atomicity) sağlamayı hedefler.
    *   Ancak, `Create` işleminde `CariHareket` oluşturma adımı **eksiktir**. Bu nedenle, fatura oluşturulduğunda stok düşüşü/artışı ve FIFO kaydı yapılırken, cari hesap (muhasebe) güncellemesi **yapılmamaktadır**.
    *   `Edit` işleminde CariHareket güncellemesi transaction içinde yer almaktadır.
    *   `Delete` işleminde ise hiçbir ilişkili kayıt (Stok, FIFO, Cari) geri alınmadığı için senkronizasyon bozulmaktadır.
*   **Soft Delete ve İlişkili Kayıtlar:**
    *   Uygulamada birçok entity için `Silindi` (soft delete) kolonu ve `HasQueryFilter` ile global filtreleme kullanılmaktadır.
    *   `FaturaController.Index` ve `Details` gibi aksiyonlarda, fatura listelenirken veya detayı gösterilirken ilişkili `Cari` entity'si `IgnoreQueryFilters()` kullanılarak yüklenmektedir. Bu sayede, fatura oluşturulduğu zamanki cari bilgisi (adı vb.) cari daha sonra silinmiş olsa bile faturada görüntülenebilmektedir. Bu, geçmişe dönük veri bütünlüğünü korumak adına doğru bir yaklaşımdır.
    *   Dropdown listeleri gibi yerlerde ise genellikle aktif ve silinmemiş kayıtlar (`Where(c => !c.Silindi && c.AktifMi)`) filtrelenerek kullanıcıya sunulmaktadır.

**Sonuç:** Stok ve FIFO hareketleri fatura işlemleriyle (Create/Edit) transaction bazında senkronize edilmeye çalışılmıştır. Ancak Cari hareket senkronizasyonu `Create` işleminde eksik, `Delete` işleminde ise tamamen yanlıştır. Soft delete kullanımı, geçmiş faturalarda ilişkili (artık silinmiş olabilecek) cari gibi bilgilerin görünür kalmasını sağlamaktadır.

## 5. Migration Yapısı ve Entity Model İlişkileri (`ApplicationDbContext`)

*   **Migration'lar:** Projede çok sayıda migration dosyası bulunmaktadır. Bu, veritabanı şemasının zaman içinde evrildiğini göstermektedir. Migration'ların içeriği detaylı incelenmemiştir ancak varlıkları, EF Core'un migration mekanizmasının kullanıldığını teyit etmektedir.
*   **Entity Tanımları:**
    *   **Veri Tipleri:** Finansal (`decimal(18,2)`), kur (`decimal(18,6)`) ve miktar (`decimal(18,3)`) alanları için uygun `decimal` hassasiyetleri tanımlanmıştır.
    *   **Varsayılan Değerler:** `Aktif`, `Silindi`, `AcilisBakiye` gibi alanlar için `HasDefaultValue` kullanımı tutarlıdır.
    *   **İlişkiler (Navigation Property & Foreign Key):** İlişkiler hem navigation property'ler hem de foreign key'ler (`CariID`, `UrunID` vb.) ile tanımlanmıştır. `OnModelCreating` içinde Fluent API kullanılarak ilişkiler detaylı şekilde yapılandırılmıştır.
    *   **Silme Davranışları (DeleteBehavior):** Çoğunlukla `Restrict` veya `NoAction` kullanılarak veri bütünlüğü korunmaya çalışılmıştır. `SetNull` kullanılan yerler (örn. `Urun.BirimID`, `Fatura.SozlesmeID`, `StokCikisDetay.StokFifoID`) ilişkinin opsiyonel olduğu durumlar için makuldür.
    *   **Potansiyel Sorun:** `Sozlesme` entity'sinde `CariID` foreign key'i `IsRequired(false)` olarak ayarlanmışken, `OnDelete(DeleteBehavior.Cascade)` olarak tanımlanmıştır. Bu, null `CariID`'ye izin verirken, ilişkili bir Cari silindiğinde tüm sözleşmelerin de silinmesine neden olur. Bu riskli bir durumdur ve `Restrict` veya `SetNull` daha güvenli olabilir.
    *   **İndeksler:** Performans için önemli alanlara (örn. `StokFifo.UrunID`, `StokFifo.GirisTarihi`, `ParaBirimi.Kod`) indeksler tanımlanmıştır. `StokFifo` için sorgu performansını artırmaya yönelik kompozit indeksler de mevcuttur.
    *   **Global Query Filters:** Soft delete (`Silindi`) ve aktiflik (`AktifMi`/`Aktif`) durumları için yaygın olarak `HasQueryFilter` kullanılmıştır. Bu, sorguları basitleştirir ancak filtrelenmiş verilere (örn. silinmiş kayıtlar) erişim gerektiğinde `IgnoreQueryFilters()` kullanımını zorunlu kılar. `StokCikisDetay` filtresi özellikle karmaşıktır.
    *   **Tutarlılık:** Fluent API ve Data Annotation kullanımı arasında belirgin bir çelişki gözlemlenmemiştir; yapılandırma ağırlıklı olarak Fluent API ile yapılmıştır.

**Sonuç:** Entity model ilişkileri ve EF Core yapılandırması genel olarak iyi durumdadır. Veri tipleri, varsayılan değerler, indeksler ve silme davranışları çoğunlukla doğru tanımlanmıştır. `Sozlesme`-`Cari` ilişkisindeki cascade delete davranışı ve global query filtrelerinin potansiyel etkileri dikkat edilmesi gereken noktalardır.

## 6. Kod Kalitesi

*   **Naming Convention:** Genel olarak .NET naming convention'larına uyulmuş görünmektedir (PascalCase for classes and methods, camelCase for local variables). Türkçe isimlendirmeler (entity, property, DbSet isimleri) yaygındır.
*   **Exception Handling:** `try-catch` blokları kullanılarak hatalar yakalanmakta ve loglanmaktadır. `StokFifoService` içinde özel `StokYetersizException` kullanılması olumludur. Ancak `FaturaController` gibi yerlerde bazen genel `Exception` yakalanmaktadır.
*   **Async/Await:** `async`/`await` kullanımı yaygın ve doğru görünmektedir. I/O bound operasyonlar (veritabanı erişimi) asenkron olarak gerçekleştirilmektedir.
*   **Validation:** ViewModel'lerde Data Annotation'lar ile temel validasyonlar yapıldığı görülmektedir. `FaturaController.Create` içinde `ModelState` kontrolü ve bazı alanlar için manuel temizleme/varsayılan atama işlemleri yapılmaktadır.
*   **Tekrarlayan Kod:** `FaturaController` içinde fatura/sipariş numarası üretme (`GenerateNewFaturaNumarasi`, `GenerateSiparisNumarasi`), otomatik irsaliye oluşturma (`OtomatikIrsaliyeOlustur`, `OtomatikIrsaliyeOlusturFromID`) gibi tekrarlayan veya benzer mantığa sahip kod blokları bulunmaktadır. Bu tür kodlar yardımcı sınıflara veya servislere taşınabilir.
*   **Servis Katmanı Kullanımı:** Daha önce belirtildiği gibi, servis katmanının tutarsız kullanımı ve Controller'ların ağır olması önemli bir kalite sorunudur.
*   **Doğrudan DbContext Kullanımı:** Controller ve servislerde Repository/UoW pattern'i yerine sıkça doğrudan `DbContext` kullanılması, katmanlı mimari prensiplerini zayıflatmaktadır.
*   **Stok Miktarı Güncelleme:** `FaturaController.Edit` içinde `Urun.StokMiktar`'ın doğrudan güncellenmesi risklidir. Stok miktarı ideal olarak `StokHareket` kayıtlarının toplamından veya `StokFifo` kayıtlarının `KalanMiktar` toplamından dinamik olarak hesaplanmalıdır.
*   **Logging:** Uygulama genelinde `ILogger` kullanımı yaygındır ve önemli adımlar loglanmaktadır.
*   **Hardcoded Değerler:** `StokFifoService` içinde döviz kuru dönüşümleri için kullanılan varsayılan/fallback kur değerleri (örn. 13000.0m, 38.0m) hardcoded'dır ve risk taşır.

**Sonuç:** Kod kalitesi değişkenlik göstermektedir. Async/await, logging gibi konularda iyi uygulamalar varken; sorumlulukların dağılımı, katmanlı mimariye uyum, kod tekrarı ve bazı riskli uygulamalar (doğrudan stok güncelleme, hardcoded fallbacks) gibi alanlarda önemli iyileştirmelere ihtiyaç vardır.

## Genel Özet ve Öneriler

Uygulama, muhasebe ve stok yönetimi için gerekli temel modülleri (FIFO, Cari, Fatura, Stok Hareketleri) içermektedir. Ancak analiz sonucunda aşağıdaki kritik sorunlar ve iyileştirme alanları tespit edilmiştir:

1.  **Transaction Bütünlüğü:**
    *   **Fatura Silme:** Fatura silme işlemi acilen düzeltilmeli, ilişkili tüm kayıtları (Stok, FIFO, Cari) transaction içinde geri alacak şekilde yeniden yazılmalıdır. `FaturaController.Edit` içindeki geri alma mantığı örnek alınabilir.
    *   **Fatura Oluşturma:** Fatura oluşturma işlemine `CariHareket` oluşturma adımı transaction içinde eklenmelidir.
2.  **Mimari ve Sorumluluk Dağılımı:**
    *   `FaturaController`'daki iş mantığı (hesaplamalar, orkestrasyon, transaction yönetimi) uygun servislere (örn. `FaturaService`, yeni bir `FaturaOrchestrationService`) taşınmalıdır.
    *   Servis katmanı (özellikle `FaturaService`, `CariHareketService`) daha etkin kullanılmalı, Controller'lar inceltilmelidir.
    *   Veri erişimi için `IUnitOfWork` ve `IRepository` pattern'leri tutarlı bir şekilde kullanılmalı, doğrudan `DbContext` kullanımından kaçınılmalıdır.
3.  **Stok Yönetimi:**
    *   `Urun.StokMiktar`'ın doğrudan güncellenmesi yerine, stok miktarının `StokHareket` veya `StokFifo` kayıtlarından dinamik olarak hesaplanması tercih edilmelidir.
    *   `StokFifoService` içinde eş zamanlılık riskini azaltmak için optimistic concurrency kontrolü (örn. RowVersion) eklenmesi değerlendirilmelidir.
    *   Döviz kuru fallback mekanizması (hardcoded değerler) yerine daha güvenilir bir strateji (örn. hata fırlatma, konfigüre edilebilir varsayılanlar) benimsenmelidir.
4.  **Kod Kalitesi:**
    *   Tekrarlayan kod blokları (numara üretme, irsaliye oluşturma) refactor edilerek yardımcı metotlara/sınıflara taşınmalıdır.
    *   ViewModel mapping için AutoMapper gibi kütüphaneler kullanılabilir.

Bu analiz, belirtilen odak noktaları çerçevesinde yapılmıştır. Uygulamanın diğer modülleri ve detayları daha kapsamlı bir inceleme gerektirebilir.
